"use strict";(self.webpackChunkls_fusion_docs=self.webpackChunkls_fusion_docs||[]).push([["89100"],{96996:function(e,n,t){t.r(n),t.d(n,{metadata:()=>i,default:()=>h,frontMatter:()=>r,contentTitle:()=>s,toc:()=>l,assets:()=>c});var i=JSON.parse('{"id":"Action_extension","title":"Action extension","description":"The actions extension technique allows the developer to declare an abstract action in one module and add to it an implementation in other modules. This technique is essentially a \\"postponed definition\\" of a branch operator, where the operator\u2019s title is defined when the property is declared, and branching conditions are added as new functionality (of classes or static objects) is added to the system. Furthermore, branching conditions (if branching is not mutually exclusive) can be added both to the beginning and to the end of the abstract action created. Similarly, this technique works with a sequence operator.","source":"@site/versioned_docs/version-v4/Action_extension.md","sourceDirName":".","slug":"/Action_extension","permalink":"/v4/Action_extension","draft":false,"unlisted":false,"editUrl":"https://github.com/lsfusion/platform/edit/v4/docs/zh-CN/Action_extension.md","tags":[],"version":"v4","lastUpdatedAt":1625651520000,"frontMatter":{"title":"Action extension"},"sidebar":"learn","previous":{"title":"Property extension","permalink":"/v4/Property_extension"},"next":{"title":"Form extension","permalink":"/v4/Form_extension"}}'),a=t(74848),o=t(28453);let r={title:"Action extension"},s,c={},l=[{value:"Polymorphic form",id:"poly",level:3},{value:"Mutual exclusion of conditions",id:"exclusive",level:3},{value:"Language",id:"language",level:3},{value:"Examples",id:"examples",level:3}];function d(e){let n={a:"a",code:"code",em:"em",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"/v4/Actions",children:"actions"})," ",(0,a.jsx)(n.a,{href:"/v4/Extensions",children:"extension"})," technique allows the developer to declare an abstract action in one ",(0,a.jsx)(n.a,{href:"/v4/Modules",children:"module"}),' and add to it an implementation in other modules. This technique is essentially a "postponed definition" of a ',(0,a.jsx)(n.a,{href:"/v4/Branching_CASE_IF_MULTI",children:"branch operator"}),", where the operator\u2019s title is defined when the property is declared, and branching conditions are added as new functionality (of ",(0,a.jsx)(n.a,{href:"/v4/Classes",children:"classes"})," or ",(0,a.jsx)(n.a,{href:"/v4/Static_objects",children:"static objects"}),") is added to the system. Furthermore, branching conditions (if branching is not mutually exclusive) can be added both to the beginning and to the end of the abstract action created. Similarly, this technique works with a ",(0,a.jsx)(n.a,{href:"/v4/Sequence",children:"sequence operator"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["For abstract actions, the expected classes of parameters must be specified. Then the platform will automatically check that the added implementations match these classes. Also, if necessary, you can check that for all descendants of the parameter classes at least one implementation is specified (or exactly one, if the conditions are ",(0,a.jsx)(n.a,{href:"/v4/Selection_CASE_IF_MULTI_OVERRIDE_EXCLUSIVE",children:"mutually exclusive"}),")."]}),"\n",(0,a.jsx)(n.p,{children:"Actions extension allows:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Implement the concept of action polymorphism by analogy with certain object-oriented programming languages."}),"\n",(0,a.jsx)(n.li,{children:'Remove dependency between modules by adding specific "entry points," to which new behavior can be added later.'}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"poly",children:"Polymorphic form"}),"\n",(0,a.jsxs)(n.p,{children:["As with a branching operator, for an abstract action there is a ",(0,a.jsx)(n.em,{children:"polymorphic form"}),", where it is possible not to define a condition explicitly, but to use as a condition matching the ",(0,a.jsx)(n.a,{href:"/v4/Property_signature_CLASS",children:"signature"})," of the action that corresponds to this condition."]}),"\n",(0,a.jsx)(n.h3,{id:"exclusive",children:"Mutual exclusion of conditions"}),"\n",(0,a.jsxs)(n.p,{children:["As for a branch operator, you can specify that all conditions of an abstract action must be ",(0,a.jsx)(n.em,{children:"mutually exclusive"}),". If this option is specified, and the conditions are not in fact mutually exclusive, the platform will throw the corresponding error."]}),"\n",(0,a.jsx)(n.p,{children:"It is worth noting that this check is no more than a hint to the platform (for better optimization), and also a kind of self-checking on the part of the developer. However, in many cases it allows to make the code more transparent and readable (especially in a polymorphic form of the abstract action)."}),"\n",(0,a.jsx)(n.h3,{id:"language",children:"Language"}),"\n",(0,a.jsxs)(n.p,{children:["The key features that implement the extension technique are the ",(0,a.jsxs)(n.a,{href:"/v4/ABSTRACT_action_operator",children:[(0,a.jsx)(n.code,{children:"ABSTRACT"})," operator"]}),", for declaring an abstract action, and the ",(0,a.jsxs)(n.a,{href:"/v4/ACTION+_statement",children:[(0,a.jsx)(n.code,{children:"ACTION+"})," statement"]}),", for adding an implementation to it."]}),"\n",(0,a.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lsf",children:"exportXls 'Export to Excel' ABSTRACT CASE (Order); // ABSTRACT CASE OVERRIDE LAST is created        \r\nexportXls (Order o) + WHEN name(currency(o)) == 'USD' THEN {\r\n    MESSAGE 'Export USD not implemented';\r\n}\r\n\r\nCLASS Task;\r\nrun 'Execute' ABSTRACT (Task); // ABSTRACT MULTI EXCLUSIVE\r\n\r\nCLASS Task1 : Task;\r\nname = DATA STRING[100] (Task);\r\nrun (Task1 t) + {\r\n    MESSAGE 'Run Task1 ' + name(t);\r\n}\r\n\r\n\r\nCLASS OrderDetail;\r\nprice = DATA NUMERIC[14,2] (OrderDetail);\r\n\r\nCLASS InvoiceDetail;\r\nprice = DATA NUMERIC[14,2] (InvoiceDetail);\r\nfill ABSTRACT LIST (OrderDetail, InvoiceDetail); // ABSTRACT LIST LAST\r\n\r\nfill (OrderDetail od, InvoiceDetail id) + {\r\n    price(id) <- price(od);\r\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lsf",children:"CLASS ABSTRACT Animal;\r\nwhoAmI  ABSTRACT ( Animal);\r\n\r\nCLASS Dog : Animal;\r\nwhoAmI (Dog d) + {  MESSAGE 'I am a dog!'; }\r\n\r\nCLASS Cat : Animal;\r\nwhoAmI (Cat c) + {  MESSAGE 'I am a \u0441at!'; }\r\n\r\nask ()  {\r\n    FOR Animal a IS Animal DO\r\n        whoAmI(a); // a corresponding message will be shown for each object\r\n}\r\n\r\nonStarted  ABSTRACT LIST ( );\r\nonStarted () + {\r\n    name(Sku s) <- '1';\r\n}\r\nonStarted () + {\r\n    name(Sku s) <- '2';\r\n}\r\n// first, the 1st action is executed, then the 2nd action\r\n\r\nCLASS Human;\r\nname = DATA STRING[100] (Human);\r\n\r\ntestName  ABSTRACT CASE ( Human);\r\n\r\ntestName (Human h) + WHEN name(h) == 'John' THEN {  MESSAGE 'I am John'; }\r\ntestName (Human h) + WHEN name(h) == 'Bob' THEN {  MESSAGE 'I am Bob'; }\n"})})]})}function h(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:function(e,n,t){t.d(n,{R:()=>r,x:()=>s});var i=t(96540);let a={},o=i.createContext(a);function r(e){let n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);