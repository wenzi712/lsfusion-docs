"use strict";(self.webpackChunkls_fusion_docs=self.webpackChunkls_fusion_docs||[]).push([["14903"],{29328:function(e,t,r){r.r(t),r.d(t,{metadata:()=>n,default:()=>h,frontMatter:()=>o,contentTitle:()=>s,toc:()=>d,assets:()=>i});var n=JSON.parse('{"id":"How-to_Inheritance_and_aggregation","title":"How-to: Inheritance and aggregation","description":"In order to demonstrate the principles of object inheritance and aggregation, let\'s implement the logic of creating batches based on receipts and production documents. Let\'s make it so that each new document with a Posted property will automatically generate exactly one new product batch.","source":"@site/versioned_docs/version-v4/How-to_Inheritance_and_aggregation.md","sourceDirName":".","slug":"/How-to_Inheritance_and_aggregation","permalink":"/v4/How-to_Inheritance_and_aggregation","draft":false,"unlisted":false,"editUrl":"https://github.com/lsfusion/platform/edit/v4/docs/zh-CN/How-to_Inheritance_and_aggregation.md","tags":[],"version":"v4","lastUpdatedAt":1623249583000,"frontMatter":{"title":"How-to: Inheritance and aggregation"},"sidebar":"learn","previous":{"title":"How-to: Constraints","permalink":"/v4/How-to_Constraints"},"next":{"title":"How-to: Searching for elements","permalink":"/v4/How-to_Searching_for_elements"}}'),c=r(74848),a=r(28453);let o={title:"How-to: Inheritance and aggregation"},s,i={},d=[];function l(e){let t={a:"a",code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(t.p,{children:"In order to demonstrate the principles of object inheritance and aggregation, let's implement the logic of creating batches based on receipts and production documents. Let's make it so that each new document with a Posted property will automatically generate exactly one new product batch."}),"\n",(0,c.jsx)(t.p,{children:"Let's update our logic with the notion of a product whose batches will be accounted for:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-lsf",children:"CLASS Item 'Product';\r\nname 'Name' = DATA ISTRING[50] (Item) IN id;\r\nFORM items 'Products'\r\n    OBJECTS i = Item\r\n    PROPERTIES(i) name, NEW, DELETE\r\n;\r\nNAVIGATOR {\r\n    NEW items;\r\n}\n"})}),"\n",(0,c.jsxs)(t.p,{children:["Let's create a ",(0,c.jsx)(t.code,{children:"Receipt"})," ",(0,c.jsx)(t.a,{href:"/v4/User_classes",children:"class"})," with objects that will indicate the receipt of products:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-lsf",children:"CLASS Receipt 'Arrival';\r\ndate 'Date' = DATA DATE (Receipt) IN id;\r\nitem 'Product' = DATA Item (Receipt);\r\nnameItem 'Product' (Receipt r) = name(item(r)) IN id;\r\nposted 'Completed' = DATA BOOLEAN (Receipt);\r\n\r\nFORM receipts 'Arrivals'\r\n    OBJECTS r = Receipt\r\n    PROPERTIES(r) date, nameItem, posted, NEW, DELETE\r\n;\r\nNAVIGATOR {\r\n    NEW receipts;\r\n}\n"})}),"\n",(0,c.jsxs)(t.p,{children:["For the purposes of this example, let's use a simplified scheme with a single class. In reality, you would be using two classes: ",(0,c.jsx)(t.code,{children:"Receipt"})," (for documents) and ",(0,c.jsx)(t.code,{children:"ReceiptDetail"})," (for document lines)."]}),"\n",(0,c.jsxs)(t.p,{children:["In a similar way, let's create a ",(0,c.jsx)(t.code,{children:"Production"})," class to be used for manufactured products:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-lsf",children:"CLASS Production 'Production';\r\ndate 'Date' = DATA DATE (Production) IN id;\r\nitem 'Product' = DATA Item (Production);\r\nnameItem 'Product' (Production p) = name(item(p)) IN id;\r\nposted 'Completed' = DATA BOOLEAN (Production);\r\n\r\nFORM productions 'Production'\r\n    OBJECTS p = Production\r\n    PROPERTIES(p) date, nameItem, posted, NEW, DELETE\r\n;\r\nNAVIGATOR {\r\n    NEW productions;\r\n}\n"})}),"\n",(0,c.jsxs)(t.p,{children:["So far, we've been only creating regular classes without any inheritance. To implement the batch logic, let's create an abstract class called ",(0,c.jsx)(t.code,{children:"Batch"}),":"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-lsf",children:"CLASS ABSTRACT Batch 'Batch';\r\ndate 'Date' = ABSTRACT DATE (Batch) IN id;\r\nitem 'Product' = ABSTRACT Item (Batch);\r\nnameItem 'Product' (Batch b) = name(item(b));\r\ntype 'Type' = ABSTRACT STRING[30] (Batch);\r\n\r\nFORM batches 'Batches'\r\n    OBJECTS b = Batch\r\n    PROPERTIES(b) READONLY date, nameItem, type, objectClassName\r\n;\r\nNAVIGATOR {\r\n    NEW batches;\r\n}\n"})}),"\n",(0,c.jsxs)(t.p,{children:["Each object of this class will correspond to one batch of a particular product. All of its ",(0,c.jsx)(t.a,{href:"/v4/Properties",children:"properties"})," will be declared abstract \u2014 that is, their implementation will differ depending on the class of a particular batch."]}),"\n",(0,c.jsxs)(t.p,{children:["You cannot directly create objects of the abstract ",(0,c.jsx)(t.code,{children:"Batch"})," class in the system. To do that, you need to declare specific classes that will be inherited from it. In particular, let's create a class for batches formed from the receipt of products:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-lsf",children:"CLASS ReceiptBatch 'Arrival based batch';\r\nbatch (Receipt receipt) = AGGR ReceiptBatch WHERE posted(receipt);\n"})}),"\n",(0,c.jsxs)(t.p,{children:["Use the ",(0,c.jsxs)(t.a,{href:"/v4/AGGR_operator",children:[(0,c.jsx)(t.code,{children:"AGGR"})," operator"]})," for each object of the ",(0,c.jsx)(t.code,{children:"Receipt"}),",  class with a defined ",(0,c.jsx)(t.code,{children:"posted"})," property to automatically create (and delete) an object of the ",(0,c.jsx)(t.code,{children:"ReceiptBatch"})," class. At this time, the system creates two properties with reciprocal object links: ",(0,c.jsx)(t.code,{children:"batch(Receipt r)"})," and ",(0,c.jsx)(t.code,{children:"receipt(ReceiptBatch b)"}),"."]}),"\n",(0,c.jsxs)(t.p,{children:["Now we need to inherit the ",(0,c.jsx)(t.code,{children:"ReceiptBatch"})," class from ",(0,c.jsx)(t.code,{children:"Batch"})," to make sure that all batches created by the receipt document also become objects of the abstract class (that is, previously declared batches):"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-lsf",children:"EXTEND CLASS ReceiptBatch : Batch;\r\ndate(ReceiptBatch rb) += date(receipt(rb));\r\nitem(ReceiptBatch rb) += item(receipt(rb));\r\ntype(ReceiptBatch rb) += 'Arrival' IF rb IS ReceiptBatch;\n"})}),"\n",(0,c.jsxs)(t.p,{children:["Inheritance is implemented with the help of the ",(0,c.jsx)(t.a,{href:"/v4/EXTEND_CLASS_statement",children:"EXTEND CLASS statement"}),". After that, for each abstract property of ",(0,c.jsx)(t.code,{children:"Batch"}),", we define how exactly it should be calculated for a specific ",(0,c.jsx)(t.code,{children:"ReceiptBatch"})," class. Date and product values are retrieved from the receipt document through the ",(0,c.jsx)(t.code,{children:"receipt(ReceiptBatch b)"})," link. The necessary string is substituted into the batch type under the condition that the object belongs to the right class (otherwise, the expression will be defined for objects of any class, and the system will generate a signature mismatch error)."]}),"\n",(0,c.jsxs)(t.p,{children:["Note that you could inherit a class directly while declaring the ",(0,c.jsx)(t.code,{children:"ReceiptBatch"})," class."]}),"\n",(0,c.jsx)(t.p,{children:"In a similar fashion, let's create batches for manufacturing documents:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-lsf",children:"CLASS ProductionBatch 'Production based batch';\r\nbatch (Production production) = AGGR ProductionBatch WHERE posted(production);\r\n\r\nEXTEND CLASS ProductionBatch : Batch;\r\ndate(ProductionBatch rb) += date(production(rb));\r\nitem(ProductionBatch rb) += item(production(rb));\r\ntype(ProductionBatch rb) += 'Production' IF rb IS ProductionBatch;\n"})}),"\n",(0,c.jsx)(t.p,{children:"If necessary, you can create a class for manual batch entry by the user:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-lsf",children:"CLASS UserBatch 'Manually created batch';\r\ndate 'Date' = DATA DATE (UserBatch) IN id;\r\nitem 'Product' = DATA Item (UserBatch);\r\nnameItem 'Product' (UserBatch b) = name(item(b));\r\n\r\nFORM userBatches 'Batches (manual)'\r\n    OBJECTS b = UserBatch\r\n    PROPERTIES(b) date, nameItem, NEW, DELETE\r\n;\r\n\r\nNAVIGATOR {\r\n    NEW userBatches;\r\n}\r\n\r\nEXTEND CLASS UserBatch : Batch;\r\ndate(UserBatch ub) += date(ub);\r\nitem(UserBatch ub) += item(ub);\r\ntype(UserBatch ub) += 'Manual' IF ub IS UserBatch;\n"})})]})}function h(e={}){let{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,c.jsx)(t,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}},28453:function(e,t,r){r.d(t,{R:()=>o,x:()=>s});var n=r(96540);let c={},a=n.createContext(c);function o(e){let t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);